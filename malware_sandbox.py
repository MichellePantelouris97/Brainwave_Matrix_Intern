import os
import psutil
import subprocess
import time
import hashlib
import json
from datetime import datetime
from scapy.all import sniff, wrpcap
from threading import Thread

# Setup: Where we will save our results and network data
REPORT_DIR = "sandbox_reports"  # Folder for reports
PCAP_FILE = "network_traffic.pcap"  # File to save network activity

# Create the folder to store reports if it doesn't already exist
os.makedirs(REPORT_DIR, exist_ok=True)


def calculate_file_hash(file_path):
    """
    Figure out a unique ID (hash) for the file.
    This is like creating a digital fingerprint for the file to identify it.
    """
    sha256_hash = hashlib.sha256()  # Use the SHA256 algorithm to calculate the hash
    with open(file_path, "rb") as file:  # Open the file in read-binary mode
        for chunk in iter(lambda: file.read(4096), b""):  # Read the file in small chunks
            sha256_hash.update(chunk)  # Update the hash with each chunk
    return sha256_hash.hexdigest()  # Return the final hash as a string


def monitor_process(pid, duration=30):
    """
    Watch what a process is doing for a set amount of time.
    This means keeping track of:
    - How much CPU it's using (processing power)
    - How much memory it's using (RAM)
    - If it's reading or writing to the computer's disk
    """
    try:
        process = psutil.Process(pid)  # Connect to the process using its ID
        start_time = time.time()  # Record the time we started monitoring
        activity_log = []  # This will store all the details about the process

        while time.time() - start_time < duration:  # Keep checking for the given time
            try:
                cpu_usage = process.cpu_percent(interval=1)  # Get CPU usage
                memory_usage = process.memory_info().rss  # Get memory usage in bytes
                io_activity = process.io_counters()  # Get disk activity (reads/writes)
                activity_log.append({
                    "time": datetime.now().isoformat(),  # When we recorded the data
                    "cpu_usage": cpu_usage,  # How much CPU it's using
                    "memory_usage": memory_usage,  # How much memory it's using
                    "read_bytes": io_activity.read_bytes,  # How much data it read
                    "write_bytes": io_activity.write_bytes,  # How much data it wrote
                })
                time.sleep(1)  # Wait for 1 second before checking again
            except psutil.NoSuchProcess:  # If the process stops during monitoring
                print(f"The process with ID {pid} has ended.")
                break
        return activity_log  # Return the list of activity details

    except psutil.NoSuchProcess:  # If the process doesn't exist when we try to monitor it
        print(f"Couldn't find a process with ID {pid}.")
        return []


def capture_network_traffic(duration=30):
    """
    Watch and save what the computer is doing on the network for a set amount of time.
    This can include websites visited, files downloaded, or connections made.
    """
    print(f"Watching network activity for {duration} seconds...")
    packets = sniff(timeout=duration)  # Record network activity for the given time
    wrpcap(PCAP_FILE, packets)  # Save the recorded activity to a file
    print("Finished recording network activity.")
    return PCAP_FILE  # Return the name of the file with network data


def execute_sample(file_path):
    """
    Try running the file we want to analyze.
    If it runs successfully, we'll get back its process ID (PID).
    """
    print(f"Running: {file_path}")
    try:
        # Run the file and start tracking it
        process = subprocess.Popen([file_path], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        return process.pid  # Return the ID of the running process
    except Exception as error:  # If something goes wrong
        print(f"Couldn't run the file. Error: {error}")
        return None


def generate_report(file_path, process_data, network_file, hash_value):
    """
    Create a detailed report about what we found:
    - The file's name and its unique hash
    - What the file did on the computer (CPU, memory, disk)
    - What network activity happened
    """
    report = {
        "file_name": os.path.basename(file_path),  # Just the file name (not the whole path)
        "file_hash": hash_value,  # The file's digital fingerprint
        "analysis_time": datetime.now().isoformat(),  # When the analysis was done
        "process_activity": process_data,  # What the file did on the computer
        "network_activity_file": network_file  # The file with network details
    }

    # Save the report in a human-readable format
    report_path = os.path.join(REPORT_DIR, f"{os.path.basename(file_path)}_report.json")
    with open(report_path, "w") as report_file:
        json.dump(report, report_file, indent=4)  # Save the report as formatted JSON
    print(f"Report saved to: {report_path}")


def main():
    """
    The main part of the script that:
    1. Asks for a file to analyze
    2. Checks if the file exists
    3. Watches what the file does on the computer and network
    4. Creates a report with all the findings
    """
    sample_file = input("Enter the full path to the file you want to analyze: ").strip()

    # Step 1: Check if the file exists
    if not os.path.isfile(sample_file):  # If the file isn't found
        print(f"Error: The file '{sample_file}' doesn't exist.")
        return

    # Step 2: Create a digital fingerprint (hash) for the file
    file_hash = calculate_file_hash(sample_file)
    print(f"The file's SHA256 Hash (digital fingerprint): {file_hash}")

    # Step 3: Start watching network activity in the background
    network_thread = Thread(target=capture_network_traffic, args=(30,))
    network_thread.start()

    # Step 4: Try running the file
    pid = execute_sample(sample_file)
    if not pid:  # If the file couldn't run
        print("Could not run the file for analysis.")
        return

    # Step 5: Monitor what the file does while it's running
    process_activity = monitor_process(pid)

    # Step 6: Wait for the network activity monitoring to finish
    network_thread.join()

    # Step 7: Generate a report with all the findings
    generate_report(sample_file, process_activity, PCAP_FILE, file_hash)


if __name__ == "__main__":
    main()
